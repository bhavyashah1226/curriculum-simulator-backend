/*
Test generated by RoostGPT for test javaUnitTest using AI Type Open AI and AI Model gpt-4

1. **Scenario: Valid Section Input**
    - Description: Check if the function returns the correct list of courses and HTTP status when a valid section is passed.
    - Steps: Pass a valid section object as an argument to the function.
    - Expected Result: The function should return a list of courses associated with the section and HTTP status 200 (OK).

2. **Scenario: Invalid Section Input**
    - Description: Check if the function handles invalid section input correctly.
    - Steps: Pass an invalid or non-existent section object to the function.
    - Expected Result: Depending on the implementation of getSectionCourses in CourseService, it should either return an empty list (if it handles non-existent sections gracefully) or throw an exception.

3. **Scenario: Null Section Input**
    - Description: Check if the function handles null section input correctly.
    - Steps: Pass a null value as section to the function.
    - Expected Result: The function should throw an appropriate exception indicating that the input cannot be null.

4. **Scenario: Section with No Courses**
    - Description: Check if the function returns the correct response when a section with no courses is passed.
    - Steps: Pass a section object with no associated courses to the function.
    - Expected Result: The function should return an empty list and HTTP status 200 (OK).

5. **Scenario: Large Number of Courses**
    - Description: Check if the function can handle a section with a large number of courses correctly.
    - Steps: Pass a section object with a large number of associated courses to the function.
    - Expected Result: The function should return a list with all the courses and HTTP status 200 (OK). The performance of the function should also be monitored to ensure it handles large inputs efficiently.

6. **Scenario: Section with Duplicate Courses**
    - Description: Check if the function handles sections with duplicate courses correctly.
    - Steps: Pass a section object with duplicate courses to the function.
    - Expected Result: Depending on the business rules, the function should either return a list with duplicate courses or a list with unique courses. The HTTP status should be 200 (OK).
*/
package alahyaoui.curriculum.controller;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import alahyaoui.curriculum.model.Course;
import alahyaoui.curriculum.model.Section;
import alahyaoui.curriculum.service.CourseService;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

public class CourseRestController_getSectionCourses_79b5517948_Test {

    @InjectMocks
    CourseRestController courseRestController;

    @Mock
    CourseService courseService;

    @BeforeEach
    public void init() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testGetSectionCourses_ValidSectionInput() {
        Section section = new Section();
        Course course = new Course();
        List<Course> courses = Arrays.asList(course);

        when(courseService.getSectionCourses(section)).thenReturn(courses);

        ResponseEntity<List<Course>> response = courseRestController.getSectionCourses(section);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(courses, response.getBody());
    }

    @Test
    public void testGetSectionCourses_InvalidSectionInput() {
        Section section = new Section();

        when(courseService.getSectionCourses(section)).thenReturn(Collections.emptyList());

        ResponseEntity<List<Course>> response = courseRestController.getSectionCourses(section);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(Collections.emptyList(), response.getBody());
    }

    @Test
    public void testGetSectionCourses_NullSectionInput() {
        Section section = null;

        assertThrows(NullPointerException.class, () -> {
            courseRestController.getSectionCourses(section);
        });
    }

    @Test
    public void testGetSectionCourses_SectionWithNoCourses() {
        Section section = new Section();

        when(courseService.getSectionCourses(section)).thenReturn(Collections.emptyList());

        ResponseEntity<List<Course>> response = courseRestController.getSectionCourses(section);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(Collections.emptyList(), response.getBody());
    }

    @Test
    public void testGetSectionCourses_LargeNumberOfCourses() {
        Section section = new Section();
        Course course = new Course();
        List<Course> courses = Arrays.asList(new Course[1000]);

        when(courseService.getSectionCourses(section)).thenReturn(courses);

        ResponseEntity<List<Course>> response = courseRestController.getSectionCourses(section);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(courses, response.getBody());
    }

    @Test
    public void testGetSectionCourses_SectionWithDuplicateCourses() {
        Section section = new Section();
        Course course = new Course();
        List<Course> courses = Arrays.asList(course, course);

        when(courseService.getSectionCourses(section)).thenReturn(courses);

        ResponseEntity<List<Course>> response = courseRestController.getSectionCourses(section);

        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(courses, response.getBody());
    }
}
