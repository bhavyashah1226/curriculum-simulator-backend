/*
Test generated by RoostGPT for test javaUnitTest using AI Type Open AI and AI Model gpt-4

1. Test Scenario: Check if the function returns a list of courses when no filter or field is provided. 
   Expected Result: The function should return a list of all available courses.

2. Test Scenario: Check if the function returns a list of courses filtered by a specific field when only field is provided.
   Expected Result: The function should return a list of courses that matches the specified field.

3. Test Scenario: Check if the function returns a list of courses that match the filter when only filter is provided.
   Expected Result: The function should return a list of courses that matches the specified filter.

4. Test Scenario: Check if the function returns a list of courses filtered by a specific field and match the filter when both filter and field are provided.
   Expected Result: The function should return a list of courses that matches both the field and filter.

5. Test Scenario: Check if the function returns an empty list when the filter or field does not match any course.
   Expected Result: The function should return an empty list.

6. Test Scenario: Check if the function returns a HTTP status code of 200 (OK) when the request is successful.
   Expected Result: The function should return a HTTP status code of 200.

7. Test Scenario: Check if the function returns a valid ResponseEntity object when called.
   Expected Result: The function should return a valid ResponseEntity object.

8. Test Scenario: Check if the function handles null values for filter and field parameters.
   Expected Result: The function should not throw a NullPointerException and should return a list of all available courses.

9. Test Scenario: Check how the function behaves with invalid input for filter and field.
   Expected Result: The function should handle invalid input gracefully, possibly returning an empty list or an error message.

10. Test Scenario: Check if the function returns the courses in a specific order (if any order is specified in the business logic).
    Expected Result: The order of courses in the returned list should match the specified order in the business logic.
*/
package alahyaoui.curriculum.controller;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import alahyaoui.curriculum.model.Course;
import alahyaoui.curriculum.service.CourseService;

import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class CourseRestController_getCourses_977b5b1a4a_Test {

    @InjectMocks
    private CourseRestController courseRestController;

    @Mock
    private CourseService courseService;

    @Test
    public void testGetCourses_NoFilterOrFieldProvided() {
        Course course1 = new Course();
        Course course2 = new Course();
        List<Course> expectedCourses = Arrays.asList(course1, course2);

        when(courseService.getCoursesBy(null, null)).thenReturn(expectedCourses);

        ResponseEntity<List<Course>> response = courseRestController.getCourses(null, null);

        assertNotNull(response);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(expectedCourses, response.getBody());

        verify(courseService, times(1)).getCoursesBy(null, null);
    }

    @Test
    public void testGetCourses_OnlyFieldProvided() {
        Course course1 = new Course();
        Course course2 = new Course();
        List<Course> expectedCourses = Arrays.asList(course1, course2);
        String field = "mathematics";

        when(courseService.getCoursesBy(null, field)).thenReturn(expectedCourses);

        ResponseEntity<List<Course>> response = courseRestController.getCourses(null, field);

        assertNotNull(response);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(expectedCourses, response.getBody());

        verify(courseService, times(1)).getCoursesBy(null, field);
    }

    @Test
    public void testGetCourses_OnlyFilterProvided() {
        Course course1 = new Course();
        Course course2 = new Course();
        List<Course> expectedCourses = Arrays.asList(course1, course2);
        String filter = "advanced";

        when(courseService.getCoursesBy(filter, null)).thenReturn(expectedCourses);

        ResponseEntity<List<Course>> response = courseRestController.getCourses(filter, null);

        assertNotNull(response);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(expectedCourses, response.getBody());

        verify(courseService, times(1)).getCoursesBy(filter, null);
    }

    @Test
    public void testGetCourses_FilterAndFieldProvided() {
        Course course1 = new Course();
        Course course2 = new Course();
        List<Course> expectedCourses = Arrays.asList(course1, course2);
        String filter = "advanced";
        String field = "mathematics";

        when(courseService.getCoursesBy(filter, field)).thenReturn(expectedCourses);

        ResponseEntity<List<Course>> response = courseRestController.getCourses(filter, field);

        assertNotNull(response);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertEquals(expectedCourses, response.getBody());

        verify(courseService, times(1)).getCoursesBy(filter, field);
    }

    @Test
    public void testGetCourses_FilterOrFieldDoesNotMatch() {
        String filter = "unmatchedFilter";
        String field = "unmatchedField";

        when(courseService.getCoursesBy(filter, field)).thenReturn(Arrays.asList());

        ResponseEntity<List<Course>> response = courseRestController.getCourses(filter, field);

        assertNotNull(response);
        assertEquals(HttpStatus.OK, response.getStatusCode());
        assertTrue(response.getBody().isEmpty());

        verify(courseService, times(1)).getCoursesBy(filter, field);
    }
}
