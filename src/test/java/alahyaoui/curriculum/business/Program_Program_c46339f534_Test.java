/*
Test generated by RoostGPT for test javaUnitTest using AI Type Open AI and AI Model gpt-4

1. Scenario: Validate if the function can handle an empty HashMap input. 
   Test Data: An empty HashMap<String, CourseStateDto>.
   Expected Result: The function should correctly handle the empty HashMap without throwing any errors.

2. Scenario: Validate if the function can handle a HashMap with a single entry.
   Test Data: A HashMap<String, CourseStateDto> with a single entry.
   Expected Result: The function should correctly store the single entry without any errors.

3. Scenario: Validate if the function can handle a HashMap with multiple entries.
   Test Data: A HashMap<String, CourseStateDto> with multiple entries.
   Expected Result: The function should correctly store all the entries without any errors.

4. Scenario: Validate if the function can handle a HashMap with null values.
   Test Data: A HashMap<String, CourseStateDto> with some entries having null values.
   Expected Result: The function should correctly handle and store the entries with null values.

5. Scenario: Validate if the function can handle a HashMap with null keys.
   Test Data: A HashMap<String, CourseStateDto> with some entries having null keys.
   Expected Result: The function should correctly handle and store the entries with null keys, considering HashMap allows null keys.

6. Scenario: Validate if the function can handle a null HashMap.
   Test Data: Null instead of a HashMap<String, CourseStateDto>.
   Expected Result: Depending on the implementation, the function might throw a NullPointerException or handle the null input gracefully.

7. Scenario: Validate if the function can handle a HashMap with large amount of entries.
   Test Data: A HashMap<String, CourseStateDto> with a large amount of entries.
   Expected Result: The function should correctly handle and store all the entries without any errors or performance issues.

8. Scenario: Validate if the function can handle a HashMap with duplicate keys.
   Test Data: A HashMap<String, CourseStateDto> with some entries having duplicate keys.
   Expected Result: The function should correctly handle and store the entries, considering HashMap does not allow duplicate keys.
*/
package alahyaoui.curriculum.business;

import java.util.HashMap;
import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.*;
import alahyaoui.curriculum.dto.CourseStateDto;

public class Program_Program_c46339f534_Test {

    private Program program;

    @Before
    public void setUp() {
        program = new Program();
    }

    @Test
    public void testProgram_EmptyHashMap() {
        HashMap<String, CourseStateDto> studentCourses = new HashMap<>();
        program = new Program(studentCourses);
        assertTrue(program.coursesToStates.isEmpty());
    }

    @Test
    public void testProgram_SingleEntry() {
        HashMap<String, CourseStateDto> studentCourses = new HashMap<>();
        studentCourses.put("1", new CourseStateDto());
        program = new Program(studentCourses);
        assertEquals(1, program.coursesToStates.size());
    }

    @Test
    public void testProgram_MultipleEntries() {
        HashMap<String, CourseStateDto> studentCourses = new HashMap<>();
        studentCourses.put("1", new CourseStateDto());
        studentCourses.put("2", new CourseStateDto());
        studentCourses.put("3", new CourseStateDto());
        program = new Program(studentCourses);
        assertEquals(3, program.coursesToStates.size());
    }

    @Test
    public void testProgram_NullValues() {
        HashMap<String, CourseStateDto> studentCourses = new HashMap<>();
        studentCourses.put("1", null);
        program = new Program(studentCourses);
        assertNull(program.coursesToStates.get("1"));
    }

    @Test
    public void testProgram_NullKeys() {
        HashMap<String, CourseStateDto> studentCourses = new HashMap<>();
        studentCourses.put(null, new CourseStateDto());
        program = new Program(studentCourses);
        assertNotNull(program.coursesToStates.get(null));
    }

    @Test(expected = NullPointerException.class)
    public void testProgram_NullHashMap() {
        program = new Program(null);
    }

    // TODO: The following test case should be uncommented and adjusted according to the actual size limit of your HashMap implementation.
    // @Test(timeout = 3000)
    // public void testProgram_LargeHashMap() {
    //     HashMap<String, CourseStateDto> studentCourses = new HashMap<>();
    //     for (int i = 0; i < 1000000; i++) {
    //         studentCourses.put(String.valueOf(i), new CourseStateDto());
    //     }
    //     program = new Program(studentCourses);
    //     assertEquals(1000000, program.coursesToStates.size());
    // }

    @Test
    public void testProgram_DuplicateKeys() {
        HashMap<String, CourseStateDto> studentCourses = new HashMap<>();
        studentCourses.put("1", new CourseStateDto());
        studentCourses.put("1", new CourseStateDto());
        program = new Program(studentCourses);
        assertEquals(1, program.coursesToStates.size());
    }
}
